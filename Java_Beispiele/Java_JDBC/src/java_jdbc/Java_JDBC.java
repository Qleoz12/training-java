/*
 *  This code is released under Creative Commons Attribution 4.0 International
 *  (CC BY 4.0) license, http://creativecommons.org/licenses/by/4.0/legalcode .
 *  That means:
 * 
 *  You are free to:
 * 
 *      Share — copy and redistribute the material in any medium or format
 *      Adapt — remix, transform, and build upon the material
 *               for any purpose, even commercially.
 * 
 *      The licensor cannot revoke these freedoms as long as you follow the
 *      license terms.
 * 
 *  Under the following terms:
 * 
 *      Attribution — You must give appropriate credit, provide a link to the
 *      license, and indicate if changes were made. You may do so in any
 *      reasonable manner, but not in any way that suggests the licensor endorses
 *      you or your use.
 * 
 *  No additional restrictions — You may not apply legal terms or technological
 *  measures that legally restrict others from doing anything the license
 *  permits.
 * 
 *
 *  2019 Aeonium Software Systems, Robert Rohm.
 */
package java_jdbc;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

/**
 *
 * @author robert
 */
public class Java_JDBC {

  /**
   * @param args the command line arguments
   */
  public static void main(String[] args) throws ClassNotFoundException, SQLException {

    // 1. Verbindung aufbauen
    Connection connection = Java_JDBC_ConnectionFactory.createJavaDBConnection();

    // 2. Ggf. Tabellen prüfen, erstellen und befüllen
    if (!Java_JDBC_Utilties.exists(connection, "personen")) {
      
      try (Statement statement = connection.createStatement()) {
        // SQL-Statement, je nach RDBMS-Syntax, ohne Ergebnis
        statement.execute(
                "CREATE TABLE personen ("
                + "  person_id INT NOT NULL GENERATED BY DEFAULT AS IDENTITY (START WITH 1, INCREMENT BY 1), "
                + "  person_name     VARCHAR(20),"
                + "  person_vorname  VARCHAR(20), "
                + "  person_alter    INT"
                + ")");
        
        statement.execute("INSERT INTO personen (person_name, person_vorname, person_alter) VALUES ('Mustermann', 'Max', 45)");
        statement.execute("INSERT INTO personen (person_name, person_vorname, person_alter) VALUES ('Lyse', 'Anna', 32)");

      } catch (SQLException sQLException) {
        sQLException.printStackTrace();
      }
    }
    
    // 3. Lesezugriff, mit PerparedStatement und ohne parametrisierte Selektion
    System.out.println("3. Lesezugriff");
    
    String sql = "SELECT * FROM personen";
    try (PreparedStatement statement = connection.prepareStatement(sql)){
      
      ResultSet resultSet = statement.executeQuery();
      
      while (resultSet.next()) {
        String name    = resultSet.getString("person_name");
        String vorname = resultSet.getString("person_vorname");
        int id         = resultSet.getInt("person_id");
        int alter      = resultSet.getInt("person_alter");
        
        System.out.printf("Person # %d: %s, %s (%d) \n", id, name, vorname, alter);
                
      }
      
    } catch (SQLException sQLException) {
      sQLException.printStackTrace();
    }
    
    // 4. Lesezugriff mit parametrisiertem Statement
    System.out.println("4. Lesezugriff mit parametrisiertem Statement:");
   
    sql = "SELECT * FROM personen WHERE person_name LIKE ? OR person_vorname LIKE ?";
    try (PreparedStatement statement = connection.prepareStatement(sql)){
      
      statement.setString(1, "M%");
      statement.setString(2, "Max");
      ResultSet resultSet = statement.executeQuery();
      
      while (resultSet.next()) {
        String name    = resultSet.getString("person_name");
        String vorname = resultSet.getString("person_vorname");
        int id         = resultSet.getInt("person_id");
        int alter      = resultSet.getInt("person_alter");
        
        System.out.printf("Person # %d: %s, %s (%d) \n", id, name, vorname, alter);
                
      }
      
    } catch (SQLException sQLException) {
      sQLException.printStackTrace();
    }
    
    // 5. Arbeit mit Transaktionen
    connection.setAutoCommit(false);
    try {
      // Explizites "begin" ist nicht nötig,
      /// SQL-Statements folgen...
      // Zum Schluss: 
      connection.commit();
    } catch (Exception e) {
      // Im Fehlerfall zurückrollen:
      connection.rollback();
    }
  }
}
